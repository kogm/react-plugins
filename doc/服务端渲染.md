## 什么是服务端渲染
```js
// 简单的说就是请求服务器路由，返回拼接html字符串给页面
// 下面express案例
res.send(
  `
    <html>
      <head>
        <title>服务端渲染</title>
      </head>
      <body>
        服务端渲染
      </body>
    </html>
  `
)
这种方式即服务端渲染，消耗的是服务端的性能（可能需要多台机器，保持稳定性，在非必要的情况下可以不用该方式）
```

## 服务端渲染（ssr/直出）
**痛点：**
  进入富客户端时代后，早期流行的架构都存在一个通病。首屏加载白屏，即所有交互数据请求逻辑都需要在客户端假爱并执行JS后才填充。针对这个问题，解决方案，就是服务端渲染。（尽早的渲染DOM结构）
  提到优化，不得不提直出 https://github.com/joeyguo/blog/issues/8
  提到React，不能不提同构 
  同构基于服务端渲染，却不止服务端渲染
  关于服务端渲染和客户端渲染的区别你可以查看 Node直出理论与实践总结https://github.com/joeyguo/blog/issues/8
**历史**: 
  后台包办时代:
  服务端渲染方案，早在后台前后包办的时代就有了，使用JSP、PHP等动态语音将数据与页面模板整合后输出给浏览器，一步到位。项目大时，修改一个页面都要启动庞大的服务，维护变得越来越难过。
  前后分离:
  前后分离后，服务端渲染的模式开始淡化。这时候服务端徐然比较尴尬，由于前后编码语言不通，连页面都不能服务用。只能让前后端开发完成后，将前端代码改为后端使用的页面模板，增大了工作了。最后也本质还是后台包办。
  语言变通:
  Node驾着祥云腾空而来，谷歌V8引擎的给力支持，众前端的拿着看家本领js开始涉足服务端，于是服务端又开始经一步进阶。
  由于前后使用相同的语言，所以代码公用到达了一个新高度。页面模板、node modules都做成前后通用。同构的雏形，只是共用的代码还是有局限.
  前后同构:
  有了node后，前端便有了更多发挥。前端框架爱开始考虑兼容服务端渲染，提供更方便的API，前后端共用一套代码，让服务端渲染越来越便捷
  不止，React做了这件事，，React将这种思想推向高潮，同构的概念开始广为人传。
**服务端优点**
  前端代码在服务端渲染，同步请求HTML时，直接返回渲染好的页面。
  1.1 利于seo
  1.2 加速首屏渲染 （客户端渲染缺点）
  1.3 服务端和客户端可以共享某些代码，避免重复定义（同构）
**其他方案**
  hypernova airbnb 服务端渲染方案
```

## react服务端渲染基本流程

DOM的一致性：
```
前后端渲染相同的Component，将输出一致的DOM结构
```
不同的生命周期：
```
服务端不会执行cdm生命周期函数，store是空的
```
客户端render时机
```
1.服务端去数据库或者反向代理服务器拉取数据 
2.根据数据生成HTML吐给客户端,
3.客户端会判断是否可以直接使用或需要重新挂载
在实际项目应用中，还需要考虑其他边角问题，例如服务器端没有 window 对象，需要做不同处理等。
```
同构
```
React的虚拟DOM以对象树的形式保存在内存中，并存在前后端的两种展露原型的形式。
借助 react 提供的API  服务端渲染 借助react-dom/server 
React v16- 
renderToString  react元素渲染出html字符串
renderToStaticMarup  用于静态文本
react v16+ API有变化
renderToNodeStream
不在使用ReactDOM.render 使用ReactDOM.hydrate

服务端和客户端都都需要配置redux

1. 客户端代码重新渲染
2. 客户端执行cdm获取数据
3. 客户端更新store
```
**注意这里服务端store会出现公用同一个store，因此不能使用单例模式**
